<!-- Autogenerated by mlir-tblgen; don't manually edit -->
### `-chlo-legalize-to-stablehlo`

_Legalizes from CHLO ops flow to StableHLO and Shape ops_

### `-shape-legalize-to-stablehlo`

_Legalize shape-related ops to StableHLO._

An experimental pass that legalizes shape-related ops to StableHLO ops.

Bringing shape and data computations together via an optional pass will
make it possible for the StableHLO ecosystem to potentially leverage the
compilation pipelines that use StableHLO operations to model dynamism.
### `-stablehlo-aggressive-folder`

_Folds StableHLO operations_


#### Options
```
-fold-float : Allow for potentially lossy computations using float type.
```
### `-stablehlo-aggressive-simplification`

_Canonicalizes StableHLO operations_

### `-stablehlo-canonicalize-dynamism`

_Canonicalizes dynamic StableHLO ops into static ops._

Replaces dynamic StableHLO ops like DynamicReshapeOp with the corresponding
static counterparts like ReshapeOp if all the dynamic elements of these ops
are actually constant.

For example, if the output_shape operand of DynamicReshapeOp is a constant
value, then the operation can be transformed to ReshapeOp.
### `-stablehlo-convert-to-signless`

_Pass to transform the IR to be on signless integers._

### `-stablehlo-legalize-composite-to-call`

_Replaces composite ops with a call to their decomposition_

Replaces composite ops with a call to their decomposition, e.g. the below:

```mlir
stablehlo.composite "my_namespace.my_op" %arg0, %arg1 {
  decomposition = @bar,
  version = 1,
  composite_attributes = {
    "my_attribute": "my_value"
  }
}
```

Will become:

```mlir
func.call @bar(%arg0, %arg1)
```

A subset of composites can be excepted from this transformation using the
"except" flag, e.g.:

```bash
stablehlo-opt --stablehlo-legalize-composite-to-call=except='foo.baz,foo.qux'
```

#### Options
```
-except : Names of composites that should not be replaced with calls.
```
### `-stablehlo-legalize-deprecated-ops`

_Legalize deprecated ops to well-supported ops._

The StableHLO v1.0 Opset Deprecations RFC (#2283) proposes to remove
several redundant ops. This pass helps to evaluate the impact of these op
removals in various compilation pipelines by legalizing them to their
long-term supported counterparts.

#### Options
```
-fail-on-unused : Fail on (mostly) unused ops that are deprecated without any fallback.
```
### `-stablehlo-legalize-quant-to-int`

_Convert from StableHLO quantized ops to StableHLO primitive ops._

Convert StableHLO programs using UniformQuantized types to semantically
equivalent integer math.
### `-stablehlo-legalize-quantized-op-to-qdq`

_Decompose StableHLO quantized ops using uniform quantize/dequantize ops._

Decompose StableHLO quantized programs using uniform quantize/dequantize
operations. For example, the following program

```mlir
func.func @add(%arg0: tensor<!quant.uniform<i8:f32,1.0:0>>, %arg1: tensor<!quant.uniform<i8:f32,2.0:1>>) ->  tensor<!quant.uniform<i8:f32,3.0:2>> {
  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<!quant.uniform<i8:f32,1.0:0>>, tensor<!quant.uniform<i8:f32,2.0:1>>) -> tensor<!quant.uniform<i8:f32,3.0:2>>
  func.return %0 : tensor<!quant.uniform<i8:f32,3.0:2>>
}
```

Will become:

```mlir
func.func @add(%arg0: tensor<!quant.uniform<i8:f32, 1.000000e+00>>, %arg1: tensor<!quant.uniform<i8:f32, 2.000000e+00:1>>) -> tensor<!quant.uniform<i8:f32, 3.000000e+00:2>> {
  %0 = stablehlo.uniform_dequantize %arg0 : (tensor<!quant.uniform<i8:f32, 1.000000e+00>>) -> tensor<f32>
  %1 = stablehlo.uniform_dequantize %arg1 : (tensor<!quant.uniform<i8:f32, 2.000000e+00:1>>) -> tensor<f32>
  %2 = stablehlo.add %0, %1 : tensor<f32>
  %3 = stablehlo.uniform_quantize %2 : (tensor<f32>) -> tensor<!quant.uniform<i8:f32, 3.000000e+00:2>>
  return %3 : tensor<!quant.uniform<i8:f32, 3.000000e+00:2>>
}
```
### `-stablehlo-legalize-to-vhlo`

_Legalize StableHLO to VHLO._

### `-stablehlo-refine-arguments`

_Refines the argument shapes of the main function._

Modifies the arguments of the main function using the input type signature.
Wraps arguments in custom_call @stablehlo.shape_refinement_operand_wrapper
to keep the IR valid before shape refinement is run.

The `refinedTypesOption` can be used to specify a list of refined types.
This can be specified in MLIR with `--types='tensor<...>,tensor<...>'`, or
passed to the pass create method. The refinement type list must specify the
type of every argument to the `main` method being refined.

#### Options
```
-types : The new types to be used for the main function's arguments, specified as an MLIR TypeRange 'tensor<1x2xf32>, ...'
```
### `-stablehlo-refine-shapes`

_Refines shapes across a StableHLO program._

Walks through a StableHLO program refining shapes within ops.

The flagship use case for this pass is specializing dynamically-shaped
programs to static shapes. If a dynamically-shaped StableHLO program has the
right structure, then updating its argument types from dynamic shapes to
static shapes and running this pass will propagate static shapes across
the program.
### `-vhlo-legalize-to-stablehlo`

_Legalize VHLO to StableHLO._

### `-vhlo-to-version`

_Convert between versions of VHLO._


#### Options
```
-target : The target version. Must be a version of the form #.#.# or 'current'.
```
